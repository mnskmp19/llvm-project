//=- NanoMipsInstrInfo.td - NanoMips Instruction Information -*- tablegen -*-=//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file describes NanoMips instructions.
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// Mips profiles and nodes
//===----------------------------------------------------------------------===//

def MipsFullAddr : SDNode<"MipsISD::FullAddr", SDTIntUnaryOp>;
def NMUnalignedLW : SDNode<"MipsISD::UALW", SDTMipsLoadLR, [SDNPHasChain, SDNPMayLoad, SDNPMemOperand]>;
def NMUnalignedLH : SDNode<"MipsISD::UALH", SDTMipsLoadLR, [SDNPHasChain, SDNPMayLoad, SDNPMemOperand]>;
def NMUnalignedSW : SDNode<"MipsISD::UASW", SDTStore, [SDNPHasChain, SDNPMayStore, SDNPMemOperand]>;
def NMUnalignedSH : SDNode<"MipsISD::UASH", SDTStore, [SDNPHasChain, SDNPMayStore, SDNPMemOperand]>;

//===----------------------------------------------------------------------===//
// nanoMIPS Operand, Complex Patterns and Transformations Definitions.
//===----------------------------------------------------------------------===//

def imm32ZExt12 : IntImmLeaf<i32, [{ return isUInt<12>(Imm.getZExtValue()); }]>;
def imm32ZExt5  : IntImmLeaf<i32, [{ return isUInt<5>(Imm.getZExtValue()); }]>;
def imm32SExt12  : IntImmLeaf<i32, [{ return isInt<12>(Imm.getSExtValue()); }]>;
// True if (N + 1) fits in 12-bit field.
def immZExt12Plus1 : PatLeaf<(imm), [{
  return isUInt<13>(N->getZExtValue()) && isUInt<12>(N->getZExtValue() + 1);
}]>;
// Immediate range covering both signed 12-bit and unsigned 16-bit immediates.
def imm32SExt12OrZExt16 : IntImmLeaf<i32, [{ return isInt<12>(Imm.getSExtValue())
                                           || isUInt<16>(Imm.getZExtValue()); }]>;

def UImm12AsmOperandClass : UImmAsmOperandClass<12, []>;

def UImm5AsmOperandClass : UImmAsmOperandClass<5, [UImm12AsmOperandClass]>;

def uimm12_nm : Operand<i32> {
  let PrintMethod = "printUImm<12>";
  let ParserMatchClass = !cast<AsmOperandClass>("UImm12AsmOperandClass");
}

def uimm5_nm : Operand<i32> {
  let PrintMethod = "printUImm<5>";
  let ParserMatchClass = !cast<AsmOperandClass>("UImm5AsmOperandClass");
}

def uimm16_simm12 : Operand<i32>;

def addrsimm9 : ComplexPattern<iPTR, 2, "selectIntAddrSImm9", [frameindex]>;
def addruimm12 : ComplexPattern<iPTR, 2, "selectIntAddrUImm12", [frameindex]>;
def addrindexed : ComplexPattern<iPTR, 2, "selectIntAddrIndexed", [frameindex]>;
def addrindexedlsl1 : ComplexPattern<iPTR, 2, "selectIntAddrIndexedLsl1", [frameindex]>;
def addrindexedlsl2 : ComplexPattern<iPTR, 2, "selectIntAddrIndexedLsl2", []>;

//===----------------------------------------------------------------------===//
//
// Instruction Descriptions
//
//===----------------------------------------------------------------------===//

// 32-bit arithmetic and logical instructions with 3 register operands.
class ArithLoginR32<string opstr, RegisterOperand RO,
                    SDPatternOperator OpNode = null_frag>:
  InstNM<(outs RO:$rd), (ins RO:$rs, RO:$rt),
         !strconcat(opstr, "\t$rd, $rs, $rt"),
         [(set RO:$rd, (OpNode RO:$rs, RO:$rt))]>, InstSize32;

// 16-bit arithmetic and logical instructions with 2 register operands.
class ArithLogicR16<string opstr, RegisterOperand RO,
                    SDPatternOperator OpNode = null_frag>:
    InstNM<(outs RO:$rt), (ins RO:$rs), !strconcat(opstr, "\t$rt, $rs"),
           [(set RO:$rt, (OpNode RO:$rs))]>, InstSize16;

// Arithmetic and logical instructions with 2 register operands and immediate.
class ArithLogicINM<string opstr, Operand Od, RegisterOperand RO,
                    SDPatternOperator imm_type = null_frag,
                    SDPatternOperator OpNode = null_frag> :
  InstNM<(outs RO:$rt), (ins RO:$rs, Od:$imm),
         !strconcat(opstr, "\t$rt, $rs, $imm"),
         [(set RO:$rt, (OpNode RO:$rs, imm_type:$imm))]>, InstSize32 {
  let isReMaterializable = 1;
}

class DivMod<string opstr, SDPatternOperator OpNode = null_frag> :
    ArithLoginR32<opstr, GPR32NMOpnd, OpNode> {
  // Need to insert TEQ, because DIV(U)/MOD(U) don't trap on division by zero.
  bit usesCustomInserter = 1;
}

class Trap<string opstr> :
  InstNM<(outs), (ins GPR32NMOpnd:$rs, GPR32NMOpnd:$rt, uimm5_nm:$imm),
         !strconcat(opstr, "\t$rt, $rs, $imm"), []>, InstSize32 {
  let hasSideEffects = 1;
  let isCTI = 1;
}

// Instructions with 1 register (dest) and 1 immediate operand.
class RegImmNM<string opstr, Operand Od, RegisterOperand RO,
               SDPatternOperator imm_type = null_frag,
               SDPatternOperator OpNode = null_frag> :
  InstNM<(outs RO:$rt), (ins Od:$imm), !strconcat(opstr, "\t$rt, $imm"),
         [(set RO:$rt, (OpNode imm_type:$imm))]>;

class LoadMemoryNM<string opstr, DAGOperand RO, DAGOperand MO,
                   SDPatternOperator OpNode = null_frag,
                   ComplexPattern Addr = addr,
                   InstrItinClass itin = NoItinerary> :
    InstNM<(outs RO:$rt), (ins MO:$addr), !strconcat(opstr, "\t$rt, $addr"),
           [(set RO:$rt, (OpNode Addr:$addr))],
           itin> {
  let DecoderMethod = "DecodeMem";
  let canFoldAsLoad = 1;
  let mayLoad = 1;
  string BaseOpcode = opstr;
}

class StoreMemoryNM<string opstr, DAGOperand RO, DAGOperand MO,
                    SDPatternOperator OpNode = null_frag,
                    ComplexPattern Addr = addr,
                    InstrItinClass itin> :
    InstNM<(outs), (ins RO:$rt, MO:$addr), !strconcat(opstr, "\t$rt, $addr"),
           [(OpNode RO:$rt, Addr:$addr)],
           itin> {
  let DecoderMethod = "DecodeMem";
  let mayStore = 1;
  string BaseOpcode = opstr;
}

class CallNM<string opstr,
             SDPatternOperator OpNode = null_frag,
             SDPatternOperator imm_type = null_frag> :
  InstNM<(outs), (ins calltarget:$addr), !strconcat(opstr, "\t$addr"),
         [(OpNode imm_type:$addr)]> {
  let DecoderMethod = "DecodeJumpTarget";
  let isCall = 1;
  let isCTI = 1;
  let Defs = [RA_NM];
}

// Indirect branch instruction.
class IndirectBranchNM<string opstr, RegisterOperand RO,
                       SDPatternOperator operator = null_frag>:
    InstNM<(outs), (ins RO:$rs), !strconcat(opstr, "\t$rs"),
           [(operator RO:$rs)]>, InstSize16 {
  let isTerminator = 1;
  let isBarrier = 1;
  let isCTI = 1;
  let isBranch = 1;
  let isIndirectBranch = 1;
}

class AdjustStack<SDPatternOperator operator> :
    PseudoInstNM<(outs), (ins i32imm:$amt1, i32imm:$amt2),
                 [(operator timm:$amt1, timm:$amt2)]> {
  let Defs = [SP_NM];
  let Uses = [SP_NM];
  let hasSideEffects = 1;
  let hasNoSchedulingInfo = 1;
}

class EffectiveAddressNM<string opstr, RegisterOperand RO> :
  InstNM<(outs RO:$rt), (ins mem_ea:$addr), !strconcat(opstr, "\t$rt, $addr"),
         [(set RO:$rt, addr:$addr)]> {
  let isCodeGenOnly = 1;
  let hasNoSchedulingInfo = 1;
  let DecoderMethod = "DecodeMem";
  string BaseOpcode = !strconcat(opstr, "_lea");
}

class UnalignedLoad<string opstr, SDNode OpNode,
                    RegisterOperand RO = GPR32NMOpnd> :
    InstNM<(outs RO:$rt), (ins mem_simm9:$addr, RO:$src),
           !strconcat(opstr, "\t$rt, $addr"),
           [(set RO:$rt, (OpNode addrsimm9:$addr, RO:$src))]>, InstSize32 {
  let DecoderMethod = "DecodeMem";
  string Constraints = "$src = $rt";
  let mayLoad = 1;
  let canFoldAsLoad = 1;
}

class UnalignedStore<string opstr, SDNode OpNode,
                     RegisterOperand RO = GPR32NMOpnd> :
    InstNM<(outs), (ins RO:$rt, mem_simm9:$addr),
           !strconcat(opstr, "\t$rt, $addr"),
           [(OpNode RO:$rt, addrsimm9:$addr)]>, InstSize32 {
  let DecoderMethod = "DecodeMem";
  let mayStore = 1;
}

class ReadHardwareNM<RegisterOperand CPURegOperand, RegisterOperand RO> :
  InstNM<(outs CPURegOperand:$rt), (ins RO:$hs, uimm5:$sel),
  "rdhwr\t$rt, $hs, $sel", []>, InstSize32 {
  let isCodeGenOnly = 1;
}

//===----------------------------------------------------------------------===//
//
// Instruction Definitions
//
//===----------------------------------------------------------------------===//

// _POOL32A0_0 pool of instructions.
def SLLV_NM  : ArithLoginR32<"sllv", GPR32NMOpnd, shl>;
def SRLV_NM  : ArithLoginR32<"srlv", GPR32NMOpnd, srl>;
def SRAV_NM  : ArithLoginR32<"srav", GPR32NMOpnd, sra>;
def ROTRV_NM : ArithLoginR32<"rotrv", GPR32NMOpnd, rotr>;
def ADD_NM   : ArithLoginR32<"add", GPR32NMOpnd>;
def ADDu_NM  : ArithLoginR32<"addu", GPR32NMOpnd, add>;
def SUB_NM   : ArithLoginR32<"sub", GPR32NMOpnd>;
def SUBu_NM  : ArithLoginR32<"subu", GPR32NMOpnd, sub>;
def AND_NM   : ArithLoginR32<"and", GPR32NMOpnd, and>;
def OR_NM    : ArithLoginR32<"or", GPR32NMOpnd, or>;
def NOR_NM   : ArithLoginR32<"nor", GPR32NMOpnd>;
def XOR_NM   : ArithLoginR32<"xor", GPR32NMOpnd, xor>;
def SLT_NM   : ArithLoginR32<"slt", GPR32NMOpnd, setlt>;
def SLTU_NM  : ArithLoginR32<"sltu", GPR32NMOpnd, setult>;
def MUL_NM   : ArithLoginR32<"mul", GPR32NMOpnd, mul>;
def MUH_NM   : ArithLoginR32<"muh", GPR32NMOpnd, mulhs>;
def MULU_NM  : ArithLoginR32<"mulu", GPR32NMOpnd>;
def MUHU_NM  : ArithLoginR32<"muhu", GPR32NMOpnd, mulhu>;
def DIV_NM   : DivMod<"div", sdiv>;
def MOD_NM   : DivMod<"mod", srem>;
def DIVU_NM  : DivMod<"divu", udiv>;
def MODU_NM  : DivMod<"modu", urem>;

// P.U12 pool of instructions
def ORI_NM   : ArithLogicINM<"ori", uimm12_nm, GPR32NMOpnd, imm32ZExt12, or>;
def XORI_NM  : ArithLogicINM<"xori", uimm12_nm, GPR32NMOpnd, imm32ZExt12, xor>;
def ANDI_NM  : ArithLogicINM<"andi", uimm12_nm, GPR32NMOpnd, imm32ZExt12, and>;
def SLTI_NM  : ArithLogicINM<"slti", uimm12_nm, GPR32NMOpnd, imm32ZExt12, setlt>;
def SLTIU_NM : ArithLogicINM<"sltiu", uimm12_nm, GPR32NMOpnd, imm32ZExt12, setult>;

// P.SHIFT pool of instructions
def SLL_NM  : ArithLogicINM<"sll", uimm5_nm, GPR32NMOpnd, imm32ZExt5, shl>;
def SRL_NM  : ArithLogicINM<"srl", uimm5_nm, GPR32NMOpnd, imm32ZExt5, srl>;
def SRA_NM  : ArithLogicINM<"sra", uimm5_nm, GPR32NMOpnd, imm32ZExt5, sra>;
def ROTR_NM : ArithLogicINM<"rotr", uimm5_nm, GPR32NMOpnd, imm32ZExt5, rotr>;

def ADDiu_NM : ArithLogicINM<"addiu", uimm16_simm12, GPR32NMOpnd,
                             imm32SExt12OrZExt16, add>;

// P.TRAP pool of instructions.
def TEQ_NM : Trap<"teq">;
def TNE_NM : Trap<"tne">;

def NOT_NM   : ArithLogicR16<"not", GPR3Opnd, not>;
def XOR16_NM : ArithLogicR16<"xor16", GPR3Opnd>;
def AND16_NM : ArithLogicR16<"and16", GPR3Opnd>;
def OR16_NM  : ArithLogicR16<"or16", GPR3Opnd>;

def JRC_NM : IndirectBranchNM<"jrc", GPR32NMOpnd>;

def BALC_NM : CallNM<"balc", MipsJmpLink, tglobaladdr>, InstSize32;

def Li_NM : RegImmNM<"li", simm32_relaxed, GPR32NMOpnd>, InstSize48;

def LEA_ADDiu_NM : EffectiveAddressNM<"addiu", GPR32NMOpnd>, InstSize32;

def RDHWR_NM : ReadHardwareNM<GPR32NMOpnd, HWRegsOpnd>;

def ADJCALLSTACKDOWN_NM : AdjustStack<callseq_start>;
def ADJCALLSTACKUP_NM   : AdjustStack<callseq_end>;

// Return instruction is matched as RetRA, then expanded into PseudoReturnNM
// after register allocation. Finally, MipsAsmPrinter expands this into JRC_NM.
def PseudoReturnNM : PseudoInstNM<(outs), (ins GPR32NMOpnd:$rs), []> {
  let isTerminator = 1;
  let isBarrier = 1;
  let isReturn = 1;
  let isCodeGenOnly = 1;
  let hasCtrlDep = 1;
  let hasExtraSrcRegAllocReq = 1;
  bit isCTI = 1;
}

// Indirect branch is matched as PseudoIndirectBranchNM and expanded to JRC_NM.
def PseudoIndirectBranchNM :
    PseudoInstNM<(outs), (ins GPR32NMOpnd:$rs), [(brind GPR32NMOpnd:$rs)]>,
    PseudoInstExpansion<(JRC_NM GPR32NMOpnd:$rs)> {
  let isTerminator = 1;
  let isBarrier = 1;
  let isBranch = 1;
  let isIndirectBranch = 1;
  bit isCTI = 1;
}

let hasPostISelHook = 1, isCall = 1, isCTI = 1, Defs = [RA_NM] in {
  def JALRC_NM : InstNM<(outs GPR32NMOpnd:$rd), (ins GPR32NMOpnd:$rs),
                        "jalrc\t$rd, $rs", []>, InstSize32;

  def JALRCPseudo : PseudoInstNM<(outs), (ins GPR32NMOpnd:$rs),
                                 [(MipsJmpLink GPR32NMOpnd:$rs)]>,
    PseudoInstExpansion<(JALRC_NM RA_NM, GPR32NMOpnd:$rs)>;
}

def imm32_NM : IntImmLeaf<i32, [{
    return (uint32_t)Imm.getZExtValue() == (uint64_t)Imm.getZExtValue();
}]>;
def : MipsPat<(i32 imm32_NM:$imm), (Li_NM imm:$imm)>, ISA_NANOMIPS;

def : MipsPat<(MipsJmpLink (i32 texternalsym:$dst)),
              (BALC_NM texternalsym:$dst)>, ISA_NANOMIPS;

def : MipsPat<(MipsFullAddr tglobaladdr:$in),
              (Li_NM tglobaladdr:$in)>, ISA_NANOMIPS;
def : MipsPat<(MipsFullAddr tglobaltlsaddr:$in),
              (Li_NM tglobaltlsaddr:$in)>, ISA_NANOMIPS;
def : MipsPat<(MipsFullAddr tblockaddress:$in),
              (Li_NM tblockaddress:$in)>, ISA_NANOMIPS;
def : MipsPat<(MipsFullAddr tjumptable:$in),
              (Li_NM tjumptable:$in)>, ISA_NANOMIPS;

def : MipsPat<(not (or GPR32NM:$rs, GPR32NM:$rt)),
              (NOR_NM GPR32NM:$rs, GPR32NM:$rt)>, ISA_NANOMIPS;

def : MipsPat<(trap), (TEQ_NM ZERO_NM, ZERO_NM, 0)>, ISA_NANOMIPS;

// SetCC patterns.
def : MipsPat<(seteq GPR32NM:$lhs, GPR32NM:$rhs),
              (SLTIU_NM (XOR_NM GPR32NM:$lhs, GPR32NM:$rhs), 1)>;
def : MipsPat<(setne GPR32NM:$lhs, GPR32NM:$rhs),
              (SLTU_NM ZERO_NM, (XOR_NM GPR32NM:$lhs, GPR32NM:$rhs))>;
def : MipsPat<(setle GPR32NM:$lhs, GPR32NM:$rhs),
              (XORI_NM (SLT_NM GPR32NM:$rhs, GPR32NM:$lhs), 1)>;
def : MipsPat<(setule GPR32NM:$lhs, GPR32NM:$rhs),
              (XORI_NM (SLTU_NM GPR32NM:$rhs, GPR32NM:$lhs), 1)>;
def : MipsPat<(setgt GPR32NM:$lhs, GPR32NM:$rhs),
              (SLT_NM GPR32NM:$rhs, GPR32NM:$lhs)>;
def : MipsPat<(setugt GPR32NM:$lhs, GPR32NM:$rhs),
              (SLTU_NM GPR32NM:$rhs, GPR32NM:$lhs)>;
def : MipsPat<(setge GPR32NM:$lhs, GPR32NM:$rhs),
              (XORI_NM (SLT_NM GPR32NM:$lhs, GPR32NM:$rhs), 1)>;
def : MipsPat<(setuge GPR32NM:$lhs, GPR32NM:$rhs),
              (XORI_NM (SLTU_NM GPR32NM:$lhs, GPR32NM:$rhs), 1)>;

//===----------------------------------------------------------------------===//
//
// Jump and Branch Instructions.
//
//===----------------------------------------------------------------------===//

// NanoMips has only 'compact' jumps and branches, with no delay slots.
// Described using IsntSE class for the moment, should use specific
// NanoMips instruction formats later to get correct sizes.  Some
// branch instructions exist in multiple different sizes, and should
// likely be distinct instructions later.

// This class is missing instruction size, because these instructions can be
// encoded in formats of different size (eg. BEQC16 and BEQC32).
class CBranchNM<string opstr, DAGOperand opnd, PatFrag cond_op,
                RegisterOperand RO>
    : InstNM<(outs), (ins RO:$rs, RO:$rt, opnd:$offset),
             !strconcat(opstr, "\t$rs, $rt, $offset"),
             [(brcond (i32 (cond_op RO:$rs, RO:$rt)), bb:$offset)]> {
  let isBranch = 1;
  let isTerminator = 1;
  let hasDelaySlot = 0;
  let Defs = [AT_NM];
  bit isCTI = 1;
}

class CBranchImmNM<string opstr, DAGOperand opnd, PatFrag cond_op,
                   RegisterOperand RO,
                   Operand imm_type, SDPatternOperator ImmOp>
    : InstSize32,
      InstNM<(outs), (ins RO:$rt, imm_type:$u, opnd:$offset),
             !strconcat(opstr, "\t$rt, $u, $offset"),
             [(brcond (i32 (cond_op RO:$rt, ImmOp:$u)), bb:$offset)]> {
  let isBranch = 1;
  let isTerminator = 1;
  let hasDelaySlot = 0;
  let Defs = [AT_NM];
  bit isCTI = 1;
}

class CBranchZeroNM<string opstr, DAGOperand opnd, PatFrag cond_op,
                    RegisterOperand RO>
    : InstSize16,
      InstNM<(outs), (ins RO:$rs, opnd:$offset),
             !strconcat(opstr, "\t$rs, $offset"),
             [(brcond (i32 (cond_op RO:$rs, 0)), bb:$offset)]> {
  let isBranch = 1;
  let isTerminator = 1;
  let Defs = [AT_NM];
  bit isCTI = 1;
}

let isCodeGenOnly = 1, hasNoSchedulingInfo = 1,
    hasDelaySlot = 0 in {

// TODO: BBEQZ/BBNEZ bit-test conditional branch instructions
def BEQC_NM  : CBranchNM<"beqc", brtarget, seteq, GPR32NMOpnd>, InstSize32;
def BEQIC_NM : CBranchImmNM<"beqic", brtarget, seteq, GPR32NMOpnd, uimm7, immZExt7>;
def BEQZC_NM : CBranchZeroNM<"beqzc", brtarget, seteq, GPR32NMOpnd>;

def BGEC_NM   : CBranchNM<"bgec", brtarget, setge, GPR32NMOpnd>, InstSize32;
def BGEIC_NM  : CBranchImmNM<"bgeic", brtarget, setge, GPR32NMOpnd, uimm7, immZExt7>;
def BGEIUC_NM : CBranchImmNM<"bgeiuc", brtarget, setuge, GPR32NMOpnd, uimm7, immZExt7>;
def BGEUC_NM  : CBranchNM<"bgeuc", brtarget, setuge, GPR32NMOpnd>, InstSize32;

def BLTC_NM   : CBranchNM<"bltc", brtarget, setlt, GPR32NMOpnd>, InstSize32;
def BLTIC_NM  : CBranchImmNM<"bltic", brtarget, setlt, GPR32NMOpnd, uimm7, immZExt7>;
def BLTIUC_NM : CBranchImmNM<"bltiuc", brtarget, setult, GPR32NMOpnd, uimm7, immZExt7>;
def BLTUC_NM  : CBranchNM<"bltuc", brtarget, setult, GPR32NMOpnd>, InstSize32;

def BNEC_NM  : CBranchNM<"bnec", brtarget, setne, GPR32NMOpnd>, InstSize32;
def BNEIC_NM : CBranchImmNM<"bneic", brtarget, setne, GPR32NMOpnd, uimm7, immZExt7>;
def BNEZC_NM : CBranchZeroNM<"bnezc", brtarget, setne, GPR32NMOpnd>;

// Unconditional branch
// TODO: native nanomips formats
def BC_NM       : JumpFJ<jmptarget, "bc", br, bb, "b">, IsBranch, ISA_NANOMIPS;

}


// Reversed branch conditions:
def : Pat<(brcond (i32 (setugt GPR32NM:$lhs, GPR32NM:$rhs)), bb:$dst),
          (BLTUC_NM GPR32NM:$rhs, GPR32NM:$lhs, bb:$dst)>, ISA_NANOMIPS;
def : Pat<(brcond (i32 (setgt GPR32NM:$lhs, GPR32NM:$rhs)), bb:$dst),
          (BLTC_NM GPR32NM:$rhs, GPR32NM:$lhs, bb:$dst)>, ISA_NANOMIPS;
def : Pat<(brcond (i32 (setule GPR32NM:$lhs, GPR32NM:$rhs)), bb:$dst),
          (BGEUC_NM GPR32NM:$rhs, GPR32NM:$lhs, bb:$dst)>, ISA_NANOMIPS;
def : Pat<(brcond (i32 (setle GPR32NM:$lhs, GPR32NM:$rhs)), bb:$dst),
          (BGEC_NM GPR32NM:$rhs, GPR32NM:$lhs, bb:$dst)>, ISA_NANOMIPS;

// Branch on integer value
def : Pat<(brcond (i32 GPR32NM:$lhs), bb:$dst),
          (BNEC_NM GPR32NM:$lhs, ZERO_NM, bb:$dst)>, ISA_NANOMIPS;


//===----------------------------------------------------------------------===//
//
// Load / store instructions
//
//===----------------------------------------------------------------------===//

let isCodeGenOnly = 1 in {

// TODO: addruimm12 and addrsimm9 need to be looked into again. Currently
//       addruimm12 needs to come before addrsimm9, because addrsimm9 handles
//       loads/store that do not fit the offset. If we put the same handling in
//       addruimm12, this will cause addrsimm9 to never get selected.
def LWs9_NM : LoadMemoryNM<"lw", GPR32NMOpnd, mem, load, addrsimm9, II_LW>, InstSize32;
def LW_NM : LoadMemoryNM<"lw", GPR32NMOpnd, mem, load, addruimm12, II_LW>, InstSize32;
def LWXS_NM : LoadMemoryNM<"lwxs", GPR32NMOpnd, mem, load, addrindexedlsl2, II_LW>, InstSize32;
def LWX_NM : LoadMemoryNM<"lwx", GPR32NMOpnd, mem, load, addrindexed, II_LW>, InstSize32;
def SW_NM : StoreMemoryNM<"sw", GPR32NMOpnd, mem, store, addruimm12, II_SW>, InstSize32;
def SWs9_NM : StoreMemoryNM<"sw", GPR32NMOpnd, mem, store, addrsimm9, II_SW>, InstSize32;
def SWXS_NM : StoreMemoryNM<"swxs", GPR32NMOpnd, mem, store, addrindexedlsl2, II_SW>, InstSize32;
def SWX_NM : StoreMemoryNM<"swx", GPR32NMOpnd, mem, store, addrindexed, II_SW>, InstSize32;

def LHU_NM : LoadMemoryNM<"lhu", GPR32NMOpnd, mem, zextloadi16, addruimm12, II_LHU>, InstSize32;
def LHUs9_NM : LoadMemoryNM<"lhu", GPR32NMOpnd, mem, zextloadi16, addrsimm9, II_LHU>, InstSize32;
def LHUXS_NM : LoadMemoryNM<"lhuxs", GPR32NMOpnd, mem, zextloadi16, addrindexedlsl1, II_LHU>, InstSize32;
def LHUX_NM : LoadMemoryNM<"lhux", GPR32NMOpnd, mem, zextloadi16, addrindexed, II_LHU>, InstSize32;
def LH_NM : LoadMemoryNM<"lh", GPR32NMOpnd, mem, sextloadi16, addruimm12, II_LH>, InstSize32;
def LHs9_NM : LoadMemoryNM<"lh", GPR32NMOpnd, mem, sextloadi16, addrsimm9, II_LH>, InstSize32;
def LHXS_NM : LoadMemoryNM<"lhxs", GPR32NMOpnd, mem, sextloadi16, addrindexedlsl1, II_LH>, InstSize32;
def LHX_NM : LoadMemoryNM<"lhx", GPR32NMOpnd, mem, sextloadi16, addrindexed, II_LH>, InstSize32;
def SH_NM : StoreMemoryNM<"sh", GPR32NMOpnd, mem, truncstorei16, addruimm12, II_SH>, InstSize32;
def SHs9_NM : StoreMemoryNM<"sh", GPR32NMOpnd, mem, truncstorei16, addrsimm9, II_SH>, InstSize32;
def SHXS_NM : StoreMemoryNM<"shxs", GPR32NMOpnd, mem, truncstorei16, addrindexedlsl1, II_SH>, InstSize32;
def SHX_NM : StoreMemoryNM<"shx", GPR32NMOpnd, mem, truncstorei16, addrindexed, II_SH>, InstSize32;

def LBU_NM : LoadMemoryNM<"lbu", GPR32NMOpnd, mem, zextloadi8, addruimm12, II_LBU>, InstSize32;
def LBUs9_NM : LoadMemoryNM<"lbu", GPR32NMOpnd, mem, zextloadi8, addrsimm9, II_LBU>, InstSize32;
def LBUX_NM : LoadMemoryNM<"lbux", GPR32NMOpnd, mem, zextloadi8, addrindexed, II_LBU>, InstSize32;
def LB_NM : LoadMemoryNM<"lb", GPR32NMOpnd, mem, sextloadi8, addruimm12, II_LB>, InstSize32;
def LBs9_NM : LoadMemoryNM<"lb", GPR32NMOpnd, mem, sextloadi8, addrsimm9, II_LB>, InstSize32;
def LBX_NM : LoadMemoryNM<"lbx", GPR32NMOpnd, mem, sextloadi8, addrindexed, II_LB>, InstSize32;
def SB_NM : StoreMemoryNM<"sb", GPR32NMOpnd, mem, truncstorei8, addruimm12, II_SB>, InstSize32;
def SBs9_NM : StoreMemoryNM<"sb", GPR32NMOpnd, mem, truncstorei8, addrsimm9, II_SB>, InstSize32;
def SBX_NM : StoreMemoryNM<"sbx", GPR32NMOpnd, mem, truncstorei8, addrindexed, II_SB>, InstSize32;

// TODO: Halfword load/store is never selected, this needs to be looked into.
def UALH_NM : UnalignedLoad<"ualh", NMUnalignedLH>;
def UALW_NM : UnalignedLoad<"ualw", NMUnalignedLW>;
def UASH_NM : UnalignedStore<"uash", NMUnalignedSH>;
def UASW_NM : UnalignedStore<"uasw", NMUnalignedSW>;

def LWGP_NM : LoadMemoryNM<"lw", GPR32NMOpnd, mem>, InstSize32;

}

// Catching out-of-range immediate loads/stores.
def : Pat<(i32 (extloadi8 GPR32NM:$rs)),
          (LBU_NM GPR32NM:$rs, 0)>, ISA_NANOMIPS;
def : Pat<(i32 (zextloadi8 GPR32NM:$rs)),
          (LBU_NM GPR32NM:$rs, 0)>, ISA_NANOMIPS;
def : Pat<(i32 (sextloadi8 GPR32NM:$rs)),
          (LB_NM GPR32NM:$rs, 0)>, ISA_NANOMIPS;
def : Pat<(truncstorei8 GPR32NM:$rt, GPR32NM:$rs),
          (SB_NM GPR32NM:$rt, GPR32NM:$rs, 0)>, ISA_NANOMIPS;
def : Pat<(i32 (extloadi16 GPR32NM:$rs)),
          (LHU_NM GPR32NM:$rs, 0)>, ISA_NANOMIPS;
def : Pat<(i32 (zextloadi16 GPR32NM:$rs)),
          (LHU_NM GPR32NM:$rs, 0)>, ISA_NANOMIPS;
def : Pat<(i32 (sextloadi16 GPR32NM:$rs)),
          (LH_NM GPR32NM:$rs, 0)>, ISA_NANOMIPS;
def : Pat<(truncstorei16 GPR32NM:$rt, GPR32NM:$rs),
          (SH_NM GPR32NM:$rt, GPR32NM:$rs, 0)>, ISA_NANOMIPS;
def : Pat<(i32 (load GPR32NM:$rs)),
          (LW_NM GPR32NM:$rs, 0)>, ISA_NANOMIPS;
def : Pat<(store GPR32NM:$rt, GPR32NM:$rs),
          (SW_NM GPR32NM:$rt, GPR32NM:$rs, 0)>, ISA_NANOMIPS;

// Any-extending loads
def : Pat<(i32 (extloadi8 addruimm12:$addr)),
          (LBU_NM addruimm12:$addr)>, ISA_NANOMIPS;
def : Pat<(i32 (extloadi8 addrsimm9:$addr)),
          (LBUs9_NM addrsimm9:$addr)>, ISA_NANOMIPS;
def : Pat<(i32 (extloadi8 addrindexed:$addr)),
          (LBUX_NM addrindexed:$addr)>, ISA_NANOMIPS;
def : Pat<(i32 (extloadi16 addruimm12:$addr)),
          (LHU_NM addruimm12:$addr)>, ISA_NANOMIPS;
def : Pat<(i32 (extloadi16 addrsimm9:$addr)),
          (LHUs9_NM addrsimm9:$addr)>, ISA_NANOMIPS;
def : Pat<(i32 (extloadi16 addrindexedlsl1:$addr)),
          (LHUXS_NM addrindexedlsl1:$addr)>, ISA_NANOMIPS;
def : Pat<(i32 (extloadi16 addrindexed:$addr)),
          (LHUX_NM addrindexed:$addr)>, ISA_NANOMIPS;

// Catching out-of-range immediate unaligned loads/stores.
def : Pat<(i32 (NMUnalignedLW GPR32NM:$rs, GPR32NM:$src)),
          (UALW_NM GPR32NM:$rs, 0, GPR32NM:$src)>, ISA_NANOMIPS;
def : Pat<(NMUnalignedSW GPR32NM:$rt, GPR32NM:$rs),
          (UASW_NM GPR32NM:$rt, GPR32NM:$rs, 0)>, ISA_NANOMIPS;
def : Pat<(i32 (NMUnalignedLH GPR32NM:$rs, GPR32NM:$src)),
          (UALH_NM GPR32NM:$rs, 0, GPR32NM:$src)>, ISA_NANOMIPS;
def : Pat<(NMUnalignedSH GPR32NM:$rt, GPR32NM:$rs),
          (UASH_NM GPR32NM:$rt, GPR32NM:$rs, 0)>, ISA_NANOMIPS;

// GP-relative load.
def : MipsPat<(i32 (load (add GP_NM, (MipsGPRel tglobaladdr:$in)))),
              (LWGP_NM GP_NM, tglobaladdr:$in)>, ISA_NANOMIPS;
def : MipsPat<(add GP_NM, (MipsGPRel tglobaladdr:$in)),
              (ADDiu_NM GP_NM, tglobaladdr:$in)>, ISA_NANOMIPS;


// Atomic load patterns.
def : MipsPat<(atomic_load_8 addr:$a), (LB_NM addr:$a)>, ISA_NANOMIPS;
def : MipsPat<(atomic_load_16 addr:$a), (LH_NM addr:$a)>, ISA_NANOMIPS;
def : MipsPat<(atomic_load_32 addr:$a), (LW_NM addr:$a)>, ISA_NANOMIPS;

// Atomic store patterns.
def : MipsPat<(atomic_store_8 addr:$a, GPR32:$v), (SB_NM GPR32:$v, addr:$a)>,
  ISA_NANOMIPS;
def : MipsPat<(atomic_store_16 addr:$a, GPR32:$v), (SH_NM GPR32:$v, addr:$a)>,
  ISA_NANOMIPS;
def : MipsPat<(atomic_store_32 addr:$a, GPR32:$v), (SW_NM GPR32:$v, addr:$a)>,
  ISA_NANOMIPS;



// Conditional Moves
def MOVZ_NM : InstNM<(outs GPR32NMOpnd:$rd),
                     (ins GPR32NMOpnd:$rs, GPR32NMOpnd:$rt, GPR32NMOpnd:$F),
                     "movz\t$rd, $rs, $rt",
                     []>, InstSize32 {
  let Constraints = "$F = $rd";
}

def MOVN_NM : InstNM<(outs GPR32NMOpnd:$rd),
                     (ins GPR32NMOpnd:$rs, GPR32NMOpnd:$rt, GPR32NMOpnd:$F),
                     "movn\t$rd, $rs, $rt",
                     []>, InstSize32 {
    let Constraints = "$F = $rd";
}

multiclass MovzPats2NM<RegisterClass CRC, RegisterClass DRC,
                     Instruction MOVZInst, Instruction XORiOp> {
  def : MipsPat<
            (select (i32 (seteq CRC:$lhs, imm32ZExt12:$uimm12_nm)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, (XORiOp CRC:$lhs, imm32ZExt12:$uimm12_nm), DRC:$F)>;
}

multiclass MovzPats0NM<RegisterClass CRC, RegisterClass DRC,
                       Instruction MOVZInst, Instruction SLTOp,
                       Instruction SLTuOp, Instruction SLTiOp,
                       Instruction SLTiuOp> {
  def : MipsPat<(select (i32 (setge CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
                (MOVZInst DRC:$T, (SLTOp CRC:$lhs, CRC:$rhs), DRC:$F)>;
  def : MipsPat<(select (i32 (setuge CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
                (MOVZInst DRC:$T, (SLTuOp CRC:$lhs, CRC:$rhs), DRC:$F)>;
  def : MipsPat<(select (i32 (setge CRC:$lhs, imm32ZExt12:$rhs)), DRC:$T, DRC:$F),
                (MOVZInst DRC:$T, (SLTiOp CRC:$lhs, imm32ZExt12:$rhs), DRC:$F)>;
  def : MipsPat<(select (i32 (setuge CRC:$lh, imm32ZExt12:$rh)), DRC:$T, DRC:$F),
                (MOVZInst DRC:$T, (SLTiuOp CRC:$lh, imm32ZExt12:$rh), DRC:$F)>;
  def : MipsPat<(select (i32 (setle CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
                (MOVZInst DRC:$T, (SLTOp CRC:$rhs, CRC:$lhs), DRC:$F)>;
  def : MipsPat<(select (i32 (setule CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
                (MOVZInst DRC:$T, (SLTuOp CRC:$rhs, CRC:$lhs), DRC:$F)>;
  def : MipsPat<(select (i32 (setgt CRC:$lhs, immZExt12Plus1:$rhs)),
                        DRC:$T, DRC:$F),
                (MOVZInst DRC:$T, (SLTiOp CRC:$lhs, (Plus1 imm:$rhs)), DRC:$F)>;
  def : MipsPat<(select (i32 (setugt CRC:$lhs, immZExt12Plus1:$rhs)),
                        DRC:$T, DRC:$F),
                (MOVZInst DRC:$T, (SLTiuOp CRC:$lhs, (Plus1 imm:$rhs)),
                          DRC:$F)>;
}

// Use MIPS conditional instruction definitions
defm : MovzPats0NM<GPR32NM, GPR32NM, MOVZ_NM, SLT_NM, SLTU_NM, SLTI_NM,
                   SLTIU_NM>, ISA_NANOMIPS;
defm : MovzPats1<GPR32NM, GPR32NM, MOVZ_NM, XOR_NM>, ISA_NANOMIPS;
defm : MovzPats2NM<GPR32NM, GPR32NM, MOVZ_NM, XORI_NM>, ISA_NANOMIPS;
defm : MovnPats<GPR32NM, GPR32NM, MOVN_NM, XOR_NM>, ISA_NANOMIPS;
